#!/usr/bin/env python
from BaseHTTPServer import HTTPServer
from SimpleHTTPServer import SimpleHTTPRequestHandler


def get_blob_sha(content):
    import sha
    header = "blob %s\0" % len(content)
    return sha.new(header + content).hexdigest()


class PathMatcher:
    '''
    A simple URL path matcher that uses Rails route syntax.
    http://guides.rubyonrails.org/routing.html#route-globbing-and-wildcard-segments

    >>> m = PathMatcher('/api/repos/local/repo/contents/docs/index.md?some=query')
    >>> m.match('/api/repos/:user/:repo/contents/*path', debug=True)
    /api/repos/(?P<user>[^/]+)/(?P<repo>[^/]+)/contents/(?P<path>.*)$
    True
    >>> m.last_match.groupdict()
    {'repo': 'repo', 'path': 'docs/index.md', 'user': 'local'}
    >>> m['user']
    'local'
    >>> m['repo']
    'repo'
    >>> m['path']
    'docs/index.md'
    >>> m.query
    'some=query'
    '''
    def __init__(self, path):
        self.last_match = None

        parts = path.split('?', 1)
        self.path = parts[0]
        self.query = parts[1] if len(parts) > 1 else None

    def match(self, route, debug=False):
        import re
        pattern = self.convert_route_to_re(route)
        if debug:
            print pattern
        self.last_match = re.match(pattern, self.path)
        return bool(self.last_match)

    @classmethod
    def convert_route_to_re(self, route):
        return r'/'.join(
            self.convert_route_part_to_re(part)
            for part in route.split('/')
        ) + r'$'

    @classmethod
    def convert_route_part_to_re(self, part):
        import re
        m = re.match(r'([:*])(\w+)$', part)

        if not m:
            return part
        elif m.group(1) == '*':
            return r'(?P<%s>.*)' % m.group(2)
        elif m.group(1) == ':':
            return r'(?P<%s>[^/]+)' % m.group(2)

    def __getitem__(self, key):
        return self.last_match.group(key)


class QaMockServerRequestHandler(SimpleHTTPRequestHandler):
    def send_augmented_index_page(self):
        import json
        self.send_response(200)
        self.send_header("Content-type", "text/html")
        self.end_headers()
        with open('index.html') as f:
            self.wfile.write(f.read())
        self.wfile.write(
            '''<script>window.qaLocalConfig = %s;</script>'''
            % json.dumps({"useMockGithubApi": True}))

    def receive_json_request(self):
        import json
        content = self.rfile.read(int(self.headers['content-length']))
        return json.loads(content)

    def send_json_response(self, code, data):
        import json
        self.send_response(code)
        self.send_header("Content-type", "application/json")
        self.end_headers()
        json.dump(data, self.wfile)

    def do_GET(self):
        m = PathMatcher(self.path)
        if m.match('/api/repos/:user/:repo/contents/*path'):
            try:
                successful_response = self.do_read_file(m['user'], m['repo'], m['path'])
            except IOError as e:
                self.send_json_response(404, {"message": "Not Found", "details": str(e)})
            else:
                self.send_json_response(200, successful_response)
        elif m.match('/api/*path'):
            self.send_json_response(400, {"error": "Invalid API method"})
        elif m.match('/'):
            self.send_augmented_index_page()
        else:
            SimpleHTTPRequestHandler.do_GET(self)

    def do_PUT(self):
        m = PathMatcher(self.path)
        if m.match('/api/repos/:user/:repo/contents/*path'):
            request_payload = self.receive_json_request()
            try:
                successful_response = self.do_write_file(m['user'], m['repo'], m['path'], request_payload['sha'], request_payload['content'])
            except IOError as e:
                self.send_json_response(404, {"message": "Not Found", "details": str(e)})
            else:
                self.send_json_response(200, successful_response)
        else:
            self.send_json_response(400, {"error": "Invalid API method"})

    def do_read_file(self, user, repo, path):
        from base64 import b64encode
        from os.path import basename

        if (user, repo) != ('local', 'repo'):
            raise IOError("This mock server can only return data for the repo 'local/repo'.")

        with open(path, 'rb') as f:
            content = f.read()

        return {
            "name": basename(path),
            "path": path,
            "sha": get_blob_sha(content),
            "size": len(content),
            "type": "file",
            "content": b64encode(content),
            "encoding": "base64",
        }

    def do_write_file(self, user, repo, path, old_sha, b64content):
        from base64 import b64decode
        from os.path import basename

        with open(path, 'rb') as f:
            actual_old_content = f.read()
        actual_old_sha = get_blob_sha(actual_old_content)
        if old_sha != actual_old_sha:
            raise IOError(
                "Old SHA doesn't match. Given SHA: %s, actual old SHA: %s"
                % (old_sha, actual_old_sha)
            )

        content = b64decode(b64content)
        with open(path, 'wb') as f:
            f.write(content)

        return {
            "content": {
                "name": basename(path),
                "path": path,
                "sha": get_blob_sha(content),
                "size": len(content),
                "type": "file",
            },
        }


if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description='A simple mock server for testing content locally.')
    parser.add_argument('-b', '--binding', type=int, dest='PORT', default=8000)
    parser.add_argument('-p', '--port', type=str, dest='IP', default='localhost')
    args = parser.parse_args()

    server = HTTPServer((args.IP, args.PORT), QaMockServerRequestHandler)
    server.serve_forever()
